%% - - - - - - - - - - - - - - -
% Problemas de Valor Inicial
% Simón Vélez                 
% Análisis Numérico           
% Octubre 2025
% - - - - - - - - - - - - - -


% Valores problema

k = 0.06; 
y0 = 3; % Valor inicial

f = @(t, y) -k * sqrt(y); % ODE a resolver

a = 0;      % tiempo inicial
b = 100;    % tiempo final
paso = 0.001;
N = (b-a)/paso; % numero de pasos

%% Método de Euler

function [t, y] = metEuler(f, a, b, y0, N)

%   t: puntos de tiempo
%   y: solucion aproximada y(t)

h = (b - a) / N;
t = a:h:b;
y = zeros(1, N + 1); 
y(1) = y0;      

    for i = 1:N
        y(i+1) = y(i) + h * f(t(i), y(i));
    end
end

[t, y] = metEuler(f, a, b, y0, N);
empty_index = find(y <= 0, 1); % Encontrar elindice donde la ec llega a 0

fprintf("Res: %.10f\n", t(empty_index))

%% Método de punto medio


function [t, y] = metPMedio(f, a, b, y0, N)

%   t: puntos de tiempo
%   y: solucion aproximada y(t)

h = (b - a) / N;
t = a:h:b;
y = zeros(1, N + 1); 
y(1) = y0;      

    for i = 1:N
        y(i+1) = y(i) + h * f(t(i) + h/2, y(i) + (h/2) * f(t(i), y(i)));
    end
end

[t, y] = metPMedio(f, a, b, y0, N);
empty_index = find(y <= 0, 1); % Encontrar el indice donde la ec llega a 0

fprintf("Res: %.10f\n", t(empty_index))

%% Método de Euler modificado


function [t, y] = metEulerMod(f, a, b, y0, N)

%   t: puntos de tiempo
%   y: solucion aproximada y(t)

h = (b - a) / N;
t = a:h:b;
y = zeros(1, N + 1); 
y(1) = y0;      

    for i = 1:N
        y(i+1) = y(i) + (h/2) * (f(t(i), y(i)) + f(t(i+1), y(i) + h * f(t(i), y(i))));
    end
end

[t, y] = metEulerMod(f, a, b, y0, N);
empty_index = find(y <= 0, 1); % Encontrar el indice donde la ec llega a 0

fprintf("Res: %.10f\n", t(empty_index))

%% Método de EU


%% RK4

function [t, y] = RK4(f, a, b, y0, N)

%   t: puntos de tiempo
%   y: solucion aproximada y(t)

h = (b - a) / N;
t = a:h:b;
y = zeros(1, N + 1); 
y(1) = y0;      

    for i = 1:N
        k1 = h * f(t(i), y(i));                      % k1 = h * f(t_i, w_i)
        k2 = h * f(t(i) + h/2, y(i) + k1/2);         % k2 = h * f(t_i + h/2, w_i + k1/2)
        k3 = h * f(t(i) + h/2, y(i) + k2/2);         % k3 = h * f(t_i + h/2, w_i + k2/2)
        k4 = h * f(t(i) + h, y(i) + k3);             % k4 = h * f(t_i + h, w_i + k3)

        y(i+1) = y(i) + (1/6) * (k1 + 2*k2 + 2*k3 + k4); % RK4
    end
end

[t, y] = RK4(f, a, b, y0, N);
empty_index = find(y <= 0, 1); % Encontrar el indice donde la ec llega a 0

fprintf("Res: %.10f\n", t(empty_index))

%% Runge Kutta Fehlberg

function [t, y] = RKF(f, a, b, y0, TOL, h_init, h_min, h_max)
% Solves the ODE y' = f(t, y) with y(a) = y0 on the interval [a, b].
% This function uses the Runge-Kutta-Fehlberg method with adaptive step size.
%
% INPUTS:
%   f      - function handle for the ODE, f(t, y)
%   a, b   - interval [a, b]
%   y0     - initial condition y(a)
%   TOL    - tolerance for the local error
%   h_init - initial step size
%   h_min  - minimum allowed step size
%   h_max  - maximum allowed step size
%
% OUTPUTS:
%   t      - array of time points
%   y      - array of approximate solution y(t)

    % Initialization
    t(1) = a;
    y(1) = y0;
    h = h_init;
    i = 1;

    while t(i) < b
        % Ensure the last step does not go past b
        if t(i) + h > b
            h = b - t(i);
        end

        % Calculate the six k values from your image
        k1 = h * f(t(i), y(i));
        k2 = h * f(t(i) + (1/4)*h, y(i) + (1/4)*k1);
        k3 = h * f(t(i) + (3/8)*h, y(i) + (3/32)*k1 + (9/32)*k2);
        k4 = h * f(t(i) + (12/13)*h, y(i) + (1932/2197)*k1 - (7200/2197)*k2 + (7296/2197)*k3);
        k5 = h * f(t(i) + h, y(i) + (439/216)*k1 - 8*k2 + (3680/513)*k3 - (845/4104)*k4);
        k6 = h * f(t(i) + (1/2)*h, y(i) - (8/27)*k1 + 2*k2 - (3544/2565)*k3 + (1859/4104)*k4 - (11/40)*k5);

        % Calculate the difference between the 5th and 4th order approximations
        % This is the |w_i+1 - w_hat_i+1| term used in your image's formula for q
        error_est = abs((1/360)*k1 - (128/4275)*k3 - (2197/75240)*k4 + (1/50)*k5 - (2/55)*k6);

        % Calculate q based on the formula from your image (using TOL for ε)
        % Added a small number to the denominator to prevent division by zero
        q = ( (TOL * h) / (2 * error_est + 1e-10) )^(1/4);
        
        % The logic from your image: if R <= ε, accept the step.
        % Here, R is represented by the estimated error.
        if error_est <= TOL
            % --- ACCEPT STEP ---
            % Store the result of the 4th order approximation
            y(i+1) = y(i) + (25/216)*k1 + (1408/2565)*k3 + (2197/4104)*k4 - (1/5)*k5;
            t(i+1) = t(i) + h;
            i = i + 1;
        end
        % --- REJECT STEP ---
        % If the error is too large, the step is rejected. 't' and 'y' are not updated.
        % The loop will re-run for the current 'i' with a new, smaller 'h'.

        % Update step size for the next iteration (whether accepted or rejected)
        % The factor 0.84 is a safety factor included in your formula
        h = 0.84 * q * h;

        % Enforce minimum and maximum step size
        h = min(h_max, max(h_min, h));
    end
end


%% Sistemas de ecuaciones